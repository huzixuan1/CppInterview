# `std::mutex` 和 `std::shared_mutex` 的区别

| 特性       | `std::mutex`                                | `std::shared_mutex`                           |
|------------|--------------------------------------------|----------------------------------------------|
| **锁类型**  | 独占锁（mutex），一次只能有一个线程持有锁 | 共享锁（shared lock）和独占锁（unique lock） |
| **读操作**  | 不允许多个线程并发读取；读和写都需要独占锁 | 允许多个线程并发读取（共享锁），无阻塞    |
| **写操作**  | 只有一个线程可以写，且会阻塞其他线程     | 只有一个线程可以写（独占锁），会阻塞读操作和其他写操作 |
| **适用场景**| 对共享资源进行独占访问的情况             | 频繁读数据，偶尔写数据的场景               |
| **性能**    | 当读操作较少时，性能较好，因为没有区分读写  | 适用于读操作占主导地位的场景，可以允许多个线程同时读，提高并发性 |
| **锁的类型**| 只能加独占锁                              | 可以加共享锁（多个线程同时读）和独占锁（一个线程写） |



什么时候使用 std::mutex？
如果你的程序中，线程操作共享资源的方式主要是写操作，且没有太多读操作，使用 std::mutex 就足够了。
std::mutex 适用于 读写交替 的场景，或者当只有少量线程进行写操作时。
性能要求不高，只关心操作的正确性时，std::mutex 是一种简单、有效的选择。
什么时候使用 std::shared_mutex？
当程序中有 大量读操作，且少量写操作时，std::shared_mutex 比 std::mutex 更适合，因为它允许多个线程同时读取数据，提高并发性。
例如，在一些高并发的 读取密集型 程序中，使用 std::shared_mutex 可以减少锁竞争，提升性能。

总结：
std::mutex 是最基本的锁机制，适用于需要完全独占访问共享资源的场景，不允许多个线程同时读写。
std::shared_mutex 则提供了 共享锁 和 独占锁，使得多个线程能够并发读取共享资源，只在写操作时才进行独占访问，适合读多写少的场景，能够提高并发性能。
