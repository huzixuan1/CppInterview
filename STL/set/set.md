## set

为什么stl中的set使用的是rb_tree而不是其他的数据结构呢，比如说hash

STL 中的 set 选择使用红黑树（rb_tree）而不是其他数据结构（如哈希表）主要是基于以下几个理由：

1. 有序性
保持顺序：红黑树是一种自平衡的二叉搜索树，它能够在插入、删除和查找时保持元素的有序性。这意味着 set 中的元素可以按顺序进行遍历。
范围操作：使用红黑树，set 可以轻松支持范围查询（例如，查找所有在某个范围内的元素），这在哈希表中是困难的，因为哈希表不维护元素的顺序。
2. 时间复杂度
高效的查找：红黑树的查找、插入和删除操作的时间复杂度均为 O(log n)，而哈希表的查找和插入在理想情况下为 O(1)，但在最坏情况下（例如，哈希冲突较多）可能退化为 O(n)。
最坏情况性能：红黑树保证在最坏情况下也能保持对数时间复杂度，而哈希表在某些情况下可能会显著降低性能。
3. 内存使用
较小的内存开销：红黑树的内存开销相对较小，因为它不需要额外的内存来存储哈希表的桶和链接指针，而是只需要维护树的节点和少量的平衡信息。
避免哈希冲突：哈希表需要处理哈希冲突，这可能导致复杂的链接结构，并且在处理哈希冲突时可能增加额外的内存使用。
4. 迭代器支持
有效的迭代：红黑树支持有效的迭代操作，能够按顺序遍历元素。对于需要排序的操作（例如，begin()、end()、lower_bound()、upper_bound() 等），红黑树提供了方便的支持。
稳定的迭代器：红黑树在元素插入和删除后仍然保持有效的迭代器，哈希表的迭代器可能在元素的插入或删除后失效。
5. 标准库一致性
一致性：STL 中的其他容器（如 map）也使用红黑树作为底层实现，这使得它们在插入、删除和查找的性能上保持一致，并提供相似的接口和行为。
总结
虽然哈希表在查找和插入方面的性能在理想情况下是优越的，但 STL 的 set 选择红黑树作为其底层实现是为了确保有序性、稳定性和可靠的性能，尤其是在处理范围查询和保证迭代器有效性方面。红黑树的这些特性使得 set 能够更好地满足特定的使用场景和需求


==========================================
std::set:

基于红黑树实现的有序集合。
存储唯一的元素，元素自动按照特定的顺序（通常是升序）排列。
不允许重复元素。

std::multiset:
也是基于红黑树实现的有序集合，但允许存储重复的元素。
元素会根据特定顺序排列，多个相同的元素可以存在于集合中。

std::unordered_set:
基于哈希表实现的无序集合。
存储唯一的元素，但不保证元素的顺序。
具有快速的查找、插入和删除操作（平均常数时间复杂度）。

std::unordered_multiset:
也是基于哈希表实现的无序集合，允许存储重复的元素。
不保证元素的顺序，但可以包含多个相同的元素。



===========================


请解释一下 std::set 的特点和用途。
它是stl中的一个关联性容器，主要的用途就是对数据操作
其内部实现了一套可以对数据进行排序的功能

std::set 和 std::unordered_set 有什么区别？
std::set其是其中存储的数据是有序且不能重复的，
std::unordered_set其中的数据是无须的
这主要得益于二者的底层数据结构不同导致的，set底层使用的是
rb_tree实现的，rb_tree是会自动的进行调整使得最终的数据是有序的；
而std::unordered_set其底层是基于hashtable实现的，它是无序的


在 std::set 中，插入、查找和删除操作的时间复杂度是多少？为什么？
如何判断 std::set 是否包含某个元素？
std::set中插入以及查找删除的时间复杂的都是O(logn),因为其底层实现的
数据结构是rb_tree,而rb_tree底层实现存在节点着色等操作，所以插入，删除，查找的
时间复杂度最坏是O(logn)


如何使用 std::set 的迭代器遍历其元素？
我记得std::set的底层是使用的rb_tree的迭代器，
而rb_tree的迭代器是双向的迭代器，就是支持前向和回退查找
基本用法如下：
set<int> s;
s.insert(1);
s.insert(2);
……
set<int>::iterator it；
for(it = s.begin();it<s.end();it++){
……
}

std::set 的迭代器与 std::vector 的迭代器有什么不同？
迭代器方面set的底层使用的是rb_tree来实现的，它是一个双向迭代器
只能进行顺序访问。然而vector它的迭代器是支持随机访问数据的，既可以通过[]的方式
获取数据，同时vector还支持+，-的操作。
从效率方面考虑vector在插入数据方面在尾部效率较高，而在中间则需要大量的移动数据，
所以效率比较低。然而set的底层使用的是rb_tree所以它的插入效率总是O(logn)



如何在 std::set 中使用自定义的比较器？请给出示例代码。
struct CustomComparator {
    bool operator()(const std::string& lhs, const std::string& rhs) const {
        return lhs.length() < rhs.length();
    }
};

std::set<std::string,CustomComparator> mySet;


std::set 在内存管理上是如何处理元素的？是否需要手动管理内存？
set内存管理我记得是交给适配器去管理的，当需要对数据进行新增插入的
时候，会又create_node函数进行创建一个节点对象。使用完成以后会有
destory进行释放。这里我理解并不需要用户进行手动管理内存空间。





请解释什么是红黑树，它的性质是什么？
红黑树是二叉平衡树的一种类型；
性质：
	结点是红色或黑色；
	根结点是黑色；
	所有叶子都是黑色；
	每个红色结点的两个子结点都是黑色；
	从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点

红黑树的自平衡机制是如何工作的？
	我记得是根据插入节点来控制的，分为几种情况吧。
	根据插入或者删除是否破坏了平衡来判断调整机制。
	需要根据LL型，RR型，LR型以及RL型来调整。
	这里我可能回答并不是特别好。



红黑树的查找、插入和删除操作的时间复杂度是多少？请解释原因。
在红黑树的查找，插入，删除的操作中时间复杂度是O(logn)
因为在查找，插入，删除的操作中需要对节点调整，着色等操作
所以时间复杂度就是O(logn)

如何确保红黑树在插入或删除节点时仍然满足红黑性质？

实现细节

请描述红黑树的节点结构，通常包含哪些成员变量？
在红黑树的实现中，旋转操作的作用是什么？请解释左旋和右旋的具体过程。
优缺点

红黑树相比于 AVL 树有什么优缺点？
在什么场景下使用红黑树更合适？
示例题

给定一个整数序列，如何使用红黑树实现对这个序列的去重并保持元素的有序性？
