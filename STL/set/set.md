## set

为什么stl中的set使用的是rb_tree而不是其他的数据结构呢，比如说hash

STL 中的 set 选择使用红黑树（rb_tree）而不是其他数据结构（如哈希表）主要是基于以下几个理由：

1. 有序性
保持顺序：红黑树是一种自平衡的二叉搜索树，它能够在插入、删除和查找时保持元素的有序性。这意味着 set 中的元素可以按顺序进行遍历。
范围操作：使用红黑树，set 可以轻松支持范围查询（例如，查找所有在某个范围内的元素），这在哈希表中是困难的，因为哈希表不维护元素的顺序。
2. 时间复杂度
高效的查找：红黑树的查找、插入和删除操作的时间复杂度均为 O(log n)，而哈希表的查找和插入在理想情况下为 O(1)，但在最坏情况下（例如，哈希冲突较多）可能退化为 O(n)。
最坏情况性能：红黑树保证在最坏情况下也能保持对数时间复杂度，而哈希表在某些情况下可能会显著降低性能。
3. 内存使用
较小的内存开销：红黑树的内存开销相对较小，因为它不需要额外的内存来存储哈希表的桶和链接指针，而是只需要维护树的节点和少量的平衡信息。
避免哈希冲突：哈希表需要处理哈希冲突，这可能导致复杂的链接结构，并且在处理哈希冲突时可能增加额外的内存使用。
4. 迭代器支持
有效的迭代：红黑树支持有效的迭代操作，能够按顺序遍历元素。对于需要排序的操作（例如，begin()、end()、lower_bound()、upper_bound() 等），红黑树提供了方便的支持。
稳定的迭代器：红黑树在元素插入和删除后仍然保持有效的迭代器，哈希表的迭代器可能在元素的插入或删除后失效。
5. 标准库一致性
一致性：STL 中的其他容器（如 map）也使用红黑树作为底层实现，这使得它们在插入、删除和查找的性能上保持一致，并提供相似的接口和行为。
总结
虽然哈希表在查找和插入方面的性能在理想情况下是优越的，但 STL 的 set 选择红黑树作为其底层实现是为了确保有序性、稳定性和可靠的性能，尤其是在处理范围查询和保证迭代器有效性方面。红黑树的这些特性使得 set 能够更好地满足特定的使用场景和需求


==========================================
std::set:

基于红黑树实现的有序集合。
存储唯一的元素，元素自动按照特定的顺序（通常是升序）排列。
不允许重复元素。

std::multiset:
也是基于红黑树实现的有序集合，但允许存储重复的元素。
元素会根据特定顺序排列，多个相同的元素可以存在于集合中。

std::unordered_set:
基于哈希表实现的无序集合。
存储唯一的元素，但不保证元素的顺序。
具有快速的查找、插入和删除操作（平均常数时间复杂度）。

std::unordered_multiset:
也是基于哈希表实现的无序集合，允许存储重复的元素。
不保证元素的顺序，但可以包含多个相同的元素。
